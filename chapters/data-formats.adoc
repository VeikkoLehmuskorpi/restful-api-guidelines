[[data-formats]]
= Data formats


[#167]
== {MUST} use JSON as payload data interchange format

Use JSON ({RFC-7159}[RFC 7159]) to represent structured (resource) data 
passed with HTTP requests and responses as body payload.
The JSON payload must use a JSON object as top-level data 
structure (if possible) to allow for future extension. This also applies to
collection resources, where you ad-hoc would use an array -- see also
<<110>>.

Additionally, the JSON payload must comply to the more restrictive Internet JSON ({RFC-7493}[RFC 7493]),
particularly

* {RFC-7493}#section-2.1[Section 2.1] on encoding of characters, and
* {RFC-7493}#section-2.3[Section 2.3] on object constraints.

As a consequence, a JSON payload must

* use {RFC-7493}#section-2.1[`UTF-8` encoding]
* consist of {RFC-7493}#section-2.1[valid Unicode strings], i.e. must not
  contain non-characters or surrogates, and
* contain only {RFC-7493}#section-2.3[unique member names] (no duplicate
  names).


[#172]
== {SHOULD} prefer standard media type name `application/json`

Use the standard media type name
`application/json` (or `application/problem+json` for <<176>>)
as content type (or accept header) information for JSON payload. 

*Hint:* Previously, this guideline allowed the use of custom media types like 
`application/x.zalando.article+json`. This usage is not recommended
anymore and should be avoided, except where it is necessary for cases of
<<114,media type versioning>>. 
Custom media types beginning with `x` bring no advantage compared to the
standard media type for JSON, and make automated processing more difficult.
They are also {RFC-6838}#section-3.4[discouraged by RFC 6838].


[#168]
== {MAY} pass non-JSON media types using data specific standard formats

Non-JSON media types may be supported, if you stick to a business object specific standard 
format for the payload data, for instance, image data format (JPG, PNG, GIF), document 
format (PDF, DOC, ODF, PPT), or archive format (TAR, ZIP). 

Generic structured data interchange formats other than JSON (e.g. XML, CSV) 
may be provided, but only additionally to JSON as default format using content negotiation, 
for specific use cases where clients may not interpret the payload structure.


[#128]
[#169]
[#170]
[#171]
[#239]
[#238]
== {MUST} use standard data formats

https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#data-types[Open API] 
(based on https://json-schema.org/understanding-json-schema/reference/string.html#format[JSON Schema])
defines formats from ISO and IETFF standards for date/time, integers/numbers and binary data.
You *must* use these formats, whenever applicable:

[cols="10%,10%,40%,40%",options="header",]
|=====================================================================
| `OpenAPI type` | `OpenAPI format` | Specification | Example
| `integer` | `int32` | 4 byte signed integer -- see https://en.wikipedia.org/wiki/Integer_(computer_science)[Wiki:Integer] | `7721071004`
| `integer` | `int64` | 8 byte signed integer -- see https://en.wikipedia.org/wiki/Integer_(computer_science)[Wiki:Integer]  | `772107100456824`
| `integer` | `bigint` | >8 byte signed integer range -- see e.g. https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html[Java Doc] | `77210710045682438959`
| `number` | `float` | `binary32` single precision decimal number -- see {IEEE-754-2008}[IEEE 754-2008/ISO 60559:2011] | `3.1415927`
| `number` | `double` | `binary64` double precision decimal number -- see {IEEE-754-2008}[IEEE 754-2008/ISO 60559:2011] | `3.141592653589793`
| `number` | `decimal` | >`binary64` double precision decimal number | `3.141592653589793238462643383279`
| `string` | `byte` | `base64url` encoded byte following {RFC-7493}#section-4.4[RFC 7493 Section 4.4] | `"VA=="`
| `string` | `binary` | `base64url` encoded byte sequence following {RFC-7493}#section-4.4[RFC 7493 Section 4.4]  | `"VGVzdA=="`
| `string` | `date` | {RFC-3339}[RFC 3339] internet profile -- subset of https://tools.ietf.org/html/rfc3339#ref-ISO8601[ISO 8601] | `"2019-07-30"`
| `string` | `date-time` | {RFC-3339}[RFC 3339] internet profile -- subset of https://tools.ietf.org/html/rfc3339#ref-ISO8601[ISO 8601] |`"2019-07-30T06:43:40.252Z"`
| `string` | `time` | {RFC-3339}[RFC 3339] internet profile -- subset of https://tools.ietf.org/html/rfc3339#ref-ISO8601[ISO 8601] | `"06:43:40.252Z"`
| `string` | `password` |  | `"secret"`
|=====================================================================

*Exception:* For passing date/time information via standard protocol headers,
HTTP https://tools.ietf.org/html/rfc7231#section-7.1.1.1[RFC 7231] requires to 
follow the date and time specification used by the Internet Message Format 
https://tools.ietf.org/html/rfc5322[RFC 5322]. 

*Note:* Formats `bigint`, `decimal` and `time` have been added to the OpenAPI defined formats. 
As an implication, the precision *must* always be provided via the format whenever 
an API defines a property of type `number` or `integer`. By this we prevent clients from 
guessing the precision incorrectly, and thereby changing the value unintentionally. The precision 
must be translated by clients and servers into the most specific language types, for instance, 
in Java `number` type with `decimal` format will translate into `BigDecimal` and `integer` 
type with `int32` format will translate to `int` or `Integer` Java types.


We add further OpenAPI formats that are useful especially in an e-commerce environment 
e.g. `language code`, `country code`, `currency`, `email` based other ISO and IETFF standards.
You *must* use these formats, whenever applicable:

[cols="10%,10%,40%,40%",options="header",]
|=====================================================================
| `OpenAPI type` | `format` | Specification | Example
| `string` | `iso-639` | two letter language code -- see {ISO-639-1}[ISO 639-1] | `"en"`
| `string` | `bcp47` | multi letter language tag -- see {BCP47}[BCP 47]. It is a compatible extension of {ISO-639-1}[ISO 639-1] optionally with additional information for language usage, like region, variant, script. | `"en-DE"`
| `string` | `iso-3166` | two letter country code -- see {ISO-3166-1-a2}[ISO 3166-1 alpha-2] | `"GB"`  *Hint:* It is `"GB"`, not `"UK"`, even though `"UK"` has seen some use at Zalando.
| `string` | `iso-4217` | three letter currency code -- see {ISO-4217}[ISO 4217] | `"EUR"`
| `string` | `gtin-13` | Global Trade Item Number -- see {GTIN}[GTIN] | `"5710798389878"`
| `string` | `email` | {RFC-5322}[RFC 5322] | `"example@zalando.de"`
| `string` | `hostname` | {RFC-1034}[RFC 1034] | `"www.zalando.de"`
| `string` | `ipv4` | {RFC-2673}[RFC 2673] | `"104.75.173.179"`
| `string` | `ipv6` | {RFC-2673}[RFC 2673] | `"2600:1401:2::8a"`
| `string` | `uri` | {RFC-3986}[RFC 3986] | `"https://www.zalando.de/"`
| `string` | `uri-template` | {RFC-6570}[RFC 6570] | `"/users/\{id\}"`
| `string` | <<144, `uuid`>> | {RFC-4122}[RFC 4122] | `"e2ab873e-b295-11e9-9c02-..."`
| `string` | `json-pointer` | {RFC-6901}[RFC 6901] | `"/items/0/id"`
| `string` | `regex` | regular expressions as defined in {ECMA-262}[ECMA 262] | `"^[a-z0-9]+$"`
|=====================================================================

*Remark:* Please note that this list of standard data formats is not exhaustive 
and everyone is encouraged to propose additions.
